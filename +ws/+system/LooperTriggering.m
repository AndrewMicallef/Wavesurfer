classdef LooperTriggering < ws.system.TriggeringSubsystem 
           
    methods
        function self = LooperTriggering(parent)
            self@ws.system.TriggeringSubsystem(parent);
        end  % function        
        
%         function acquireHardwareResources(self)
%             self.setupInternalSweepBasedTriggers();
%         end
        
        function setCoreSettingsToMatchPackagedOnes(self,settings)
            for i=1:length(self.CoreFieldNames_)
                fieldName = self.CoreFieldNames_{i} ;
                self.(fieldName) = settings.(fieldName) ;
            end
        end
        
        function releaseHardwareResources(self)
            self.teardownInternalSweepBasedTriggers();
        end
        
        function delete(self)
            try
                self.releaseHardwareResources();
            catch me %#ok<NASGU>
                % Can't throw in the delete() function
            end                
        end  % function
                        
        function debug(self) %#ok<MANU>
            % This is to make it easy to examine the internals of the
            % object
            keyboard
        end  % function
    end  % methods block
    
    methods        
        function startAllTriggerTasks(self)
            % This gets called once per sweep, to start() all the relevant
            % counter trigger tasks.
            
            % Start the acq & stim trigger tasks
            self.startAllDistinctSweepBasedTriggerTasks_();                
        end  % function
        
        function startAllDistinctSweepBasedTriggerTasks_(self)
            triggerSchemes = self.getUniqueInternalSweepBasedTriggersInOrderForStarting_();
            for idx = 1:numel(triggerSchemes) ,
                thisTriggerScheme=triggerSchemes{idx};
                if thisTriggerScheme==self.StimulationTriggerScheme ,
                    %fprintf('About to set self.IsStimulationCounterTriggerTaskRunning=true in location 3\n');
                    self.IsStimulationCounterTriggerTaskRunning=true;
                end                    
                thisTriggerScheme.start();
            end        
%             % Now produce a pulse on the master trigger, which will truly start things
%             self.MasterTriggerDABSTask_.writeDigitalData(true);
%             self.MasterTriggerDABSTask_.writeDigitalData(false);            
        end  % function
        
        function willPerformRun(self) %#ok<MANU>
        end  % function
        
        function willPerformSweep(self)
            self.setupInternalSweepBasedTriggers();
        end  % function

        function didCompleteSweep(self)
            self.teardownInternalSweepBasedTriggers();            
        end  % function
        
        function didAbortSweep(self)
            self.teardownInternalSweepBasedTriggers();
        end  % function
        
        function didCompleteRun(self)
            self.teardownInternalSweepBasedTriggers();
        end  % function
        
        function didAbortRun(self)
            self.teardownInternalSweepBasedTriggers();
        end  % function
        
        function setupInternalSweepBasedTriggers(self)        
            triggerSchemes = self.getUniqueInternalSweepBasedTriggersInOrderForStarting_();
            for idx = 1:numel(triggerSchemes) ,
                thisTriggerScheme=triggerSchemes{idx};
                thisTriggerScheme.setup();
%                 % Each trigger output is generated by a nidaqmx counter
%                 % task.  These tasks can themselves be configured to start
%                 % when they receive a trigger.  Here, we set the non-acq
%                 % trigger outputs to start when they receive a trigger edge on the
%                 % same PFI line that triggers the acquisition task.
%                 if thisTriggerScheme.Target ~= self.AcquisitionTriggerScheme.Target ,
%                     thisTriggerScheme.configureStartTrigger(self.AcquisitionTriggerScheme.PFIID, self.AcquisitionTriggerScheme.Edge);
%                 end                
                thisTriggerScheme.configureStartTrigger(self.MasterTriggerPFIID_, self.MasterTriggerEdge_);                                
            end  % function            
        end  % function
        
%         function triggerSourceDone(self,triggerSource)
%             % Called "from below" when the counter trigger task finishes
%             %fprintf('Triggering::triggerSourceDone()\n');
%             if self.StimulationTriggerScheme.IsInternal ,
%                 if triggerSource==self.StimulationTriggerScheme.Target ,
%                     self.IsStimulationCounterTriggerTaskRunning=false;
%                     self.Parent.internalStimulationCounterTriggerTaskComplete();
%                 end
%             end            
%         end  % function 
    end  % methods block
            
    methods (Access = protected)
        % Allows access to protected and protected variables from ws.mixin.Coding.
        function out = getPropertyValue(self, name)
            out = self.(name);
        end  % function
        
        % Allows access to protected and protected variables from ws.mixin.Coding.
        function setPropertyValue(self, name, value)
            self.(name) = value;
        end  % function
    end  % protected methods block
    
    methods (Access = protected)
        function result = getUniqueInternalSweepBasedTriggersInOrderForStarting_(self)
            % Just what it says on the tin.  For starting, want the acq
            % trigger last so that the stim trigger can trigger off it if
            % they're using the same source.  Result is a cell array.
            triggerSchemes = {self.StimulationTriggerScheme self.AcquisitionTriggerScheme} ;
            %self.StimulationTriggerScheme.IsInternal
            %self.AcquisitionTriggerScheme.IsInternal            
            isInternal=cellfun(@(scheme)(scheme.IsInternal),triggerSchemes);
            internalTriggerSchemes=triggerSchemes(isInternal);

            % If more than one internal trigger, need to check whether
            % their sources are identical.  If so, only want to return one,
            % so we don't start an internal trigger twice.
            if length(internalTriggerSchemes)>1 ,
                if self.StimulationTriggerScheme.Target==self.AcquisitionTriggerScheme.Target ,
                    % We pick the acq one, even though it shouldn't matter 
                    result=internalTriggerSchemes(2);
                else
                    result=internalTriggerSchemes;
                end
            else
                result=internalTriggerSchemes;
            end
        end  % function
        
        function teardownInternalSweepBasedTriggers(self)
%             if self.ContinuousModeTriggerScheme.IsInternal ,
%                 self.ContinuousModeTriggerScheme.clear();
%             end
            
            triggerSchemes = self.getUniqueInternalSweepBasedTriggersInOrderForStarting_();
            for idx = 1:numel(triggerSchemes)
                triggerSchemes{idx}.teardown();
            end
        end  % function
    end
            
    methods
        function poll(self,timeSinceSweepStart)
            % Call the task to do the real work
            self.AcquisitionTriggerScheme.poll(timeSinceSweepStart);
            self.StimulationTriggerScheme.poll(timeSinceSweepStart);
        end
    end    
end
